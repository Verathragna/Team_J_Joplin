import shim from '@joplin/lib/shim';
import * as React from 'react';
import { useEffect, useMemo, useRef, useState } from 'react';
import { Animated, ViewStyle } from 'react-native';

interface Props {
	// Should be a timestamp, as generated by performance.now():
	hideAfter: number;
	children: React.ReactNode;
}

const FadeOut: React.FC<Props> = props => {
	const [hidden, setHidden] = useState(false);
	const hiddenRef = useRef(hidden);
	hiddenRef.current = hidden;

	const animatedOpacity = useMemo(() => {
		const animation = new Animated.Value(1);

		animation.addListener((state) => {
			const hidden = state.value <= 0.01;
			if (hidden !== hiddenRef.current) {
				setHidden(hidden);
			}
		});
		return animation;
	}, []);

	const hideTimeoutRef = useRef(null);
	const animationRef = useRef<Animated.CompositeAnimation|null>(null);
	useEffect(() => {
		animationRef.current?.stop();
		animationRef.current = null;

		if (hideTimeoutRef.current) {
			shim.clearTimeout(hideTimeoutRef.current);
		}

		const timeout = props.hideAfter - performance.now();
		animatedOpacity.setValue(timeout > 0 ? 1 : 0);
		if (timeout < 0) {
			return;
		}

		hideTimeoutRef.current = shim.setTimeout(() => {
			hideTimeoutRef.current = null;
			animationRef.current = Animated.timing(animatedOpacity, {
				toValue: 0,
				duration: 1000,
				useNativeDriver: true,
			});
			animationRef.current.start();
		}, timeout);
	}, [props.hideAfter, animatedOpacity]);

	const style = useMemo((): ViewStyle => {
		return {
			opacity: animatedOpacity,
			display: hidden ? 'none' : undefined,
		};
	}, [animatedOpacity, hidden]);

	return <Animated.View style={style}>
		{props.children}
	</Animated.View>;
};

export default FadeOut;
